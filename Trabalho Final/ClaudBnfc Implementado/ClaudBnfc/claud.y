/* -*- c -*- File generated by the BNF Converter (bnfc 2.9.5). */

/* Parser definition to be used with Bison. */

/* Generate header file for lexer. */
%defines "Bison.h"

/* Reentrant parser */
%pure_parser
  /* From Bison 2.3b (2008): %define api.pure full */
%lex-param   { yyscan_t scanner }
%parse-param { yyscan_t scanner }

/* Turn on line/column tracking in the claud_lloc structure: */
%locations

/* Argument to the parser to be filled with the parsed tree. */
%parse-param { YYSTYPE *result }

%{
/* Begin C preamble code */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "Absyn.h"

#define YYMAXDEPTH 10000000

/* The type yyscan_t is defined by flex, but we need it in the parser already. */
#ifndef YY_TYPEDEF_YY_SCANNER_T
#define YY_TYPEDEF_YY_SCANNER_T
typedef void* yyscan_t;
#endif

typedef struct yy_buffer_state *YY_BUFFER_STATE;
extern YY_BUFFER_STATE claud__scan_string(const char *str, yyscan_t scanner);
extern void claud__delete_buffer(YY_BUFFER_STATE buf, yyscan_t scanner);

extern void claud_lex_destroy(yyscan_t scanner);
extern char* claud_get_text(yyscan_t scanner);

extern yyscan_t claud__initialize_lexer(FILE * inp);

/* List reversal functions. */

/* End C preamble code */
%}

%union
{
  int    _int;
  char   _char;
  double _double;
  char*  _string;
  S s_;
  Block block_;
  CMDS cmds_;
  CMD cmd_;
  ATB atb_;
  EXP exp_;
  SE se_;
  OPerL operl_;
  OPerA opera_;
  OPL opl_;
  CLAUDDIZ clauddiz_;
  RECEBA receba_;
  ATE ate_;
  FAZAI fazai_;
  VALUE value_;
  Type type_;
  VET vet_;
  STRUCT struct_;
  HeteroElements heteroelements_;
  HeteroElement heteroelement_;
  FUNC func_;
  GOTO goto_;
  LABEL label_;
  ConjInt conjint_;
  ConjReal conjreal_;
  ConjString conjstring_;
  CONST const_;
  POINT point_;
}

%{
void yyerror(YYLTYPE *loc, yyscan_t scanner, YYSTYPE *result, const char *msg)
{
  fprintf(stderr, "error: %d,%d: %s at %s\n",
    loc->first_line, loc->first_column, msg, claud_get_text(scanner));
}

int yyparse(yyscan_t scanner, YYSTYPE *result);

extern int yylex(YYSTYPE *lvalp, YYLTYPE *llocp, yyscan_t scanner);
%}

%token          _ERROR_
%token          _LPAREN       /* ( */
%token          _RPAREN       /* ) */
%token          _STAR         /* * */
%token          _PLUS         /* + */
%token          _COMMA        /* , */
%token          _MINUS        /* - */
%token          _SLASH        /* / */
%token          _COLON        /* : */
%token          _SEMI         /* ; */
%token          _LT           /* < */
%token          _LDARROW      /* <= */
%token          _LTGT         /* <> */
%token          _EQ           /* = */
%token          _DEQ          /* == */
%token          _GT           /* > */
%token          _GTEQ         /* >= */
%token          _KW_ATE       /* ATE */
%token          _KW_BAH       /* BAH */
%token          _KW_CONST     /* CONST */
%token          _KW_Claud     /* Claud */
%token          _KW_ClaudDiz  /* ClaudDiz */
%token          _KW_FAZAI     /* FAZAI */
%token          _KW_FUNC      /* FUNC */
%token          _KW_GOTO      /* GOTO */
%token          _KW_ISTRUCT   /* ISTRUCT */
%token          _KW_LABEL     /* LABEL */
%token          _KW_Receba    /* Receba */
%token          _KW_SE        /* SE */
%token          _KW_TCHE      /* TCHE */
%token          _LBRACK       /* [ */
%token          _RBRACK       /* ] */
%token          _KW_float     /* float */
%token          _KW_floaty    /* floaty */
%token          _KW_gaucho    /* gaucho */
%token          _KW_int       /* int */
%token          _KW_interu    /* interu */
%token          _KW_kd        /* kd */
%token          _KW_main      /* main */
%token          _KW_string    /* string */
%token          _KW_stringo   /* stringo */
%token          _LBRACE       /* { */
%token          _BAR          /* | */
%token          _RBRACE       /* } */
%token<_string> _STRING_
%token<_int>    _INTEGER_
%token<_double> _DOUBLE_
%token<_string> _IDENT_

%type <s_> S
%type <block_> Block
%type <cmds_> CMDS
%type <cmd_> CMD
%type <atb_> ATB
%type <exp_> EXP
%type <se_> SE
%type <operl_> OPerL
%type <opera_> OPerA
%type <opl_> OPL
%type <clauddiz_> CLAUDDIZ
%type <receba_> RECEBA
%type <ate_> ATE
%type <fazai_> FAZAI
%type <value_> VALUE
%type <type_> Type
%type <vet_> VET
%type <struct_> STRUCT
%type <heteroelements_> HeteroElements
%type <heteroelement_> HeteroElement
%type <func_> FUNC
%type <goto_> GOTO
%type <label_> LABEL
%type <conjint_> ConjInt
%type <conjreal_> ConjReal
%type <conjstring_> ConjString
%type <const_> CONST
%type <point_> POINT

%start S

%%

S : _KW_main _KW_Claud _LPAREN _KW_kd _KW_gaucho _RPAREN Block { $$ = make_Sst($7); result->s_ = $$; }
;
Block : _LBRACE CMDS _RBRACE { $$ = make_LBlock($2); result->block_ = $$; }
;
CMDS : CMD { $$ = make_CMDSCMD($1); result->cmds_ = $$; }
  | CMD CMDS { $$ = make_CMDS1($1, $2); result->cmds_ = $$; }
;
CMD : ATB { $$ = make_CMDATB($1); result->cmd_ = $$; }
  | SE { $$ = make_CMDSE($1); result->cmd_ = $$; }
  | ATE { $$ = make_CMDATE($1); result->cmd_ = $$; }
  | FAZAI { $$ = make_CMDFAZAI($1); result->cmd_ = $$; }
  | CLAUDDIZ { $$ = make_CMDCLAUDDIZ($1); result->cmd_ = $$; }
  | RECEBA { $$ = make_CMDRECEBA($1); result->cmd_ = $$; }
  | CONST { $$ = make_CMDCONST($1); result->cmd_ = $$; }
  | VET { $$ = make_CMDVET($1); result->cmd_ = $$; }
  | FUNC { $$ = make_CMDFUNC($1); result->cmd_ = $$; }
  | GOTO { $$ = make_CMDGOTO($1); result->cmd_ = $$; }
  | LABEL { $$ = make_CMDLABEL($1); result->cmd_ = $$; }
  | STRUCT { $$ = make_CMDSTRUCT($1); result->cmd_ = $$; }
  | POINT { $$ = make_CMDPOINT($1); result->cmd_ = $$; }
;
ATB : Type _IDENT_ _EQ VALUE _SEMI { $$ = make_ATB1($1, $2, $4); result->atb_ = $$; }
  | Type _IDENT_ _EQ EXP _SEMI { $$ = make_ATB2($1, $2, $4); result->atb_ = $$; }
;
EXP : VALUE OPerA VALUE { $$ = make_EXP1($1, $2, $3); result->exp_ = $$; }
  | EXP OPerA VALUE { $$ = make_EXP2($1, $2, $3); result->exp_ = $$; }
;
SE : _KW_SE _KW_BAH _LPAREN OPL _RPAREN Block { $$ = make_SE1($4, $6); result->se_ = $$; }
  | _KW_SE _KW_BAH _LPAREN OPL _RPAREN Block _KW_TCHE Block { $$ = make_SE2($4, $6, $8); result->se_ = $$; }
;
OPerL : _GT { $$ = make_OPerL1(); result->operl_ = $$; }
  | _GTEQ { $$ = make_OPerL2(); result->operl_ = $$; }
  | _LT { $$ = make_OPerL3(); result->operl_ = $$; }
  | _LDARROW { $$ = make_OPerL4(); result->operl_ = $$; }
  | _DEQ { $$ = make_OPerL5(); result->operl_ = $$; }
  | _LTGT { $$ = make_OPerL6(); result->operl_ = $$; }
;
OPerA : _SLASH { $$ = make_OPerA1(); result->opera_ = $$; }
  | _STAR { $$ = make_OPerA2(); result->opera_ = $$; }
  | _PLUS { $$ = make_OPerA3(); result->opera_ = $$; }
  | _MINUS { $$ = make_OPerA4(); result->opera_ = $$; }
;
OPL : VALUE OPerL VALUE { $$ = make_OPL1($1, $2, $3); result->opl_ = $$; }
;
CLAUDDIZ : _KW_ClaudDiz _LPAREN VALUE _RPAREN _SEMI { $$ = make_CLAUDDIZ1($3); result->clauddiz_ = $$; }
;
RECEBA : _KW_Receba _LPAREN Type _IDENT_ _RPAREN _SEMI { $$ = make_RECEBA1($3, $4); result->receba_ = $$; }
;
ATE : _KW_ATE _LPAREN OPL _RPAREN Block { $$ = make_ATE1($3, $5); result->ate_ = $$; }
;
FAZAI : _KW_FAZAI _LPAREN Type _IDENT_ _EQ VALUE _BAR OPL _BAR _INTEGER_ _RPAREN Block { $$ = make_FAZAI1($3, $4, $6, $8, $10, $12); result->fazai_ = $$; }
;
VALUE : _IDENT_ { $$ = make_VALUEIdent($1); result->value_ = $$; }
  | _STRING_ { $$ = make_VALUEString($1); result->value_ = $$; }
  | _INTEGER_ { $$ = make_VALUEInteger($1); result->value_ = $$; }
  | _DOUBLE_ { $$ = make_VALUEDouble($1); result->value_ = $$; }
;
Type : _KW_interu { $$ = make_Type_interu(); result->type_ = $$; }
  | _KW_floaty { $$ = make_Type_floaty(); result->type_ = $$; }
  | _KW_stringo { $$ = make_Type_stringo(); result->type_ = $$; }
;
VET : Type _IDENT_ _LBRACK _INTEGER_ _RBRACK _SEMI { $$ = make_VET1($1, $2, $4); result->vet_ = $$; }
  | _KW_int _IDENT_ _LBRACK _INTEGER_ _RBRACK _EQ _LBRACK ConjInt _RBRACK _SEMI { $$ = make_VET2($2, $4, $8); result->vet_ = $$; }
  | _KW_float _IDENT_ _LBRACK _INTEGER_ _RBRACK _EQ _LBRACK ConjReal _RBRACK _SEMI { $$ = make_VET3($2, $4, $8); result->vet_ = $$; }
  | _KW_string _IDENT_ _LBRACK _INTEGER_ _RBRACK _EQ _LBRACK ConjString _RBRACK _SEMI { $$ = make_VET4($2, $4, $8); result->vet_ = $$; }
;
STRUCT : _KW_ISTRUCT _LBRACK _INTEGER_ _RBRACK _EQ _LBRACE HeteroElements _RBRACE _SEMI { $$ = make_STRUCT1($3, $7); result->struct_ = $$; }
;
HeteroElements : HeteroElement { $$ = make_HeteroElementsHeteroElement($1); result->heteroelements_ = $$; }
  | HeteroElement _COMMA HeteroElements { $$ = make_HeteroElements1($1, $3); result->heteroelements_ = $$; }
;
HeteroElement : _STRING_ { $$ = make_HeteroElementString($1); result->heteroelement_ = $$; }
  | _DOUBLE_ { $$ = make_HeteroElementDouble($1); result->heteroelement_ = $$; }
  | _INTEGER_ { $$ = make_HeteroElementInteger($1); result->heteroelement_ = $$; }
;
FUNC : _KW_FUNC _IDENT_ _LPAREN _RPAREN Block { $$ = make_FUNC1($2, $5); result->func_ = $$; }
;
GOTO : _KW_GOTO _INTEGER_ _SEMI { $$ = make_GOTO1($2); result->goto_ = $$; }
;
LABEL : _KW_LABEL _INTEGER_ _COLON Block { $$ = make_LABEL1($2, $4); result->label_ = $$; }
;
ConjInt : _INTEGER_ { $$ = make_ConjIntInteger($1); result->conjint_ = $$; }
  | _INTEGER_ _COMMA ConjInt { $$ = make_ConjInt1($1, $3); result->conjint_ = $$; }
;
ConjReal : _DOUBLE_ { $$ = make_ConjRealDouble($1); result->conjreal_ = $$; }
  | _DOUBLE_ _COMMA ConjReal { $$ = make_ConjReal1($1, $3); result->conjreal_ = $$; }
;
ConjString : _STRING_ { $$ = make_ConjStringString($1); result->conjstring_ = $$; }
  | _STRING_ _COMMA ConjString { $$ = make_ConjString1($1, $3); result->conjstring_ = $$; }
;
CONST : _KW_CONST Type _IDENT_ _EQ VALUE _SEMI { $$ = make_LConst($2, $3, $5); result->const_ = $$; }
;
POINT : Type _STAR _IDENT_ _EQ _IDENT_ _SEMI { $$ = make_LPoint($1, $3, $5); result->point_ = $$; }
;

%%


/* Entrypoint: parse S from file. */
S pS(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = claud__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  claud_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.s_;
  }
}

/* Entrypoint: parse S from string. */
S psS(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = claud__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = claud__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  claud__delete_buffer(buf, scanner);
  claud_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.s_;
  }
}

/* Entrypoint: parse Block from file. */
Block pBlock(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = claud__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  claud_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.block_;
  }
}

/* Entrypoint: parse Block from string. */
Block psBlock(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = claud__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = claud__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  claud__delete_buffer(buf, scanner);
  claud_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.block_;
  }
}

/* Entrypoint: parse CMDS from file. */
CMDS pCMDS(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = claud__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  claud_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.cmds_;
  }
}

/* Entrypoint: parse CMDS from string. */
CMDS psCMDS(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = claud__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = claud__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  claud__delete_buffer(buf, scanner);
  claud_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.cmds_;
  }
}

/* Entrypoint: parse CMD from file. */
CMD pCMD(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = claud__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  claud_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.cmd_;
  }
}

/* Entrypoint: parse CMD from string. */
CMD psCMD(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = claud__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = claud__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  claud__delete_buffer(buf, scanner);
  claud_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.cmd_;
  }
}

/* Entrypoint: parse ATB from file. */
ATB pATB(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = claud__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  claud_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.atb_;
  }
}

/* Entrypoint: parse ATB from string. */
ATB psATB(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = claud__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = claud__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  claud__delete_buffer(buf, scanner);
  claud_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.atb_;
  }
}

/* Entrypoint: parse EXP from file. */
EXP pEXP(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = claud__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  claud_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.exp_;
  }
}

/* Entrypoint: parse EXP from string. */
EXP psEXP(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = claud__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = claud__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  claud__delete_buffer(buf, scanner);
  claud_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.exp_;
  }
}

/* Entrypoint: parse SE from file. */
SE pSE(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = claud__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  claud_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.se_;
  }
}

/* Entrypoint: parse SE from string. */
SE psSE(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = claud__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = claud__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  claud__delete_buffer(buf, scanner);
  claud_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.se_;
  }
}

/* Entrypoint: parse OPerL from file. */
OPerL pOPerL(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = claud__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  claud_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.operl_;
  }
}

/* Entrypoint: parse OPerL from string. */
OPerL psOPerL(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = claud__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = claud__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  claud__delete_buffer(buf, scanner);
  claud_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.operl_;
  }
}

/* Entrypoint: parse OPerA from file. */
OPerA pOPerA(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = claud__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  claud_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.opera_;
  }
}

/* Entrypoint: parse OPerA from string. */
OPerA psOPerA(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = claud__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = claud__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  claud__delete_buffer(buf, scanner);
  claud_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.opera_;
  }
}

/* Entrypoint: parse OPL from file. */
OPL pOPL(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = claud__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  claud_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.opl_;
  }
}

/* Entrypoint: parse OPL from string. */
OPL psOPL(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = claud__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = claud__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  claud__delete_buffer(buf, scanner);
  claud_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.opl_;
  }
}

/* Entrypoint: parse CLAUDDIZ from file. */
CLAUDDIZ pCLAUDDIZ(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = claud__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  claud_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.clauddiz_;
  }
}

/* Entrypoint: parse CLAUDDIZ from string. */
CLAUDDIZ psCLAUDDIZ(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = claud__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = claud__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  claud__delete_buffer(buf, scanner);
  claud_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.clauddiz_;
  }
}

/* Entrypoint: parse RECEBA from file. */
RECEBA pRECEBA(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = claud__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  claud_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.receba_;
  }
}

/* Entrypoint: parse RECEBA from string. */
RECEBA psRECEBA(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = claud__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = claud__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  claud__delete_buffer(buf, scanner);
  claud_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.receba_;
  }
}

/* Entrypoint: parse ATE from file. */
ATE pATE(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = claud__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  claud_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.ate_;
  }
}

/* Entrypoint: parse ATE from string. */
ATE psATE(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = claud__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = claud__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  claud__delete_buffer(buf, scanner);
  claud_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.ate_;
  }
}

/* Entrypoint: parse FAZAI from file. */
FAZAI pFAZAI(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = claud__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  claud_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.fazai_;
  }
}

/* Entrypoint: parse FAZAI from string. */
FAZAI psFAZAI(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = claud__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = claud__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  claud__delete_buffer(buf, scanner);
  claud_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.fazai_;
  }
}

/* Entrypoint: parse VALUE from file. */
VALUE pVALUE(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = claud__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  claud_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.value_;
  }
}

/* Entrypoint: parse VALUE from string. */
VALUE psVALUE(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = claud__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = claud__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  claud__delete_buffer(buf, scanner);
  claud_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.value_;
  }
}

/* Entrypoint: parse Type from file. */
Type pType(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = claud__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  claud_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.type_;
  }
}

/* Entrypoint: parse Type from string. */
Type psType(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = claud__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = claud__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  claud__delete_buffer(buf, scanner);
  claud_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.type_;
  }
}

/* Entrypoint: parse VET from file. */
VET pVET(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = claud__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  claud_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.vet_;
  }
}

/* Entrypoint: parse VET from string. */
VET psVET(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = claud__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = claud__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  claud__delete_buffer(buf, scanner);
  claud_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.vet_;
  }
}

/* Entrypoint: parse STRUCT from file. */
STRUCT pSTRUCT(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = claud__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  claud_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.struct_;
  }
}

/* Entrypoint: parse STRUCT from string. */
STRUCT psSTRUCT(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = claud__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = claud__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  claud__delete_buffer(buf, scanner);
  claud_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.struct_;
  }
}

/* Entrypoint: parse HeteroElements from file. */
HeteroElements pHeteroElements(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = claud__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  claud_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.heteroelements_;
  }
}

/* Entrypoint: parse HeteroElements from string. */
HeteroElements psHeteroElements(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = claud__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = claud__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  claud__delete_buffer(buf, scanner);
  claud_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.heteroelements_;
  }
}

/* Entrypoint: parse HeteroElement from file. */
HeteroElement pHeteroElement(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = claud__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  claud_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.heteroelement_;
  }
}

/* Entrypoint: parse HeteroElement from string. */
HeteroElement psHeteroElement(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = claud__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = claud__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  claud__delete_buffer(buf, scanner);
  claud_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.heteroelement_;
  }
}

/* Entrypoint: parse FUNC from file. */
FUNC pFUNC(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = claud__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  claud_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.func_;
  }
}

/* Entrypoint: parse FUNC from string. */
FUNC psFUNC(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = claud__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = claud__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  claud__delete_buffer(buf, scanner);
  claud_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.func_;
  }
}

/* Entrypoint: parse GOTO from file. */
GOTO pGOTO(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = claud__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  claud_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.goto_;
  }
}

/* Entrypoint: parse GOTO from string. */
GOTO psGOTO(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = claud__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = claud__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  claud__delete_buffer(buf, scanner);
  claud_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.goto_;
  }
}

/* Entrypoint: parse LABEL from file. */
LABEL pLABEL(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = claud__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  claud_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.label_;
  }
}

/* Entrypoint: parse LABEL from string. */
LABEL psLABEL(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = claud__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = claud__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  claud__delete_buffer(buf, scanner);
  claud_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.label_;
  }
}

/* Entrypoint: parse ConjInt from file. */
ConjInt pConjInt(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = claud__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  claud_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.conjint_;
  }
}

/* Entrypoint: parse ConjInt from string. */
ConjInt psConjInt(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = claud__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = claud__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  claud__delete_buffer(buf, scanner);
  claud_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.conjint_;
  }
}

/* Entrypoint: parse ConjReal from file. */
ConjReal pConjReal(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = claud__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  claud_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.conjreal_;
  }
}

/* Entrypoint: parse ConjReal from string. */
ConjReal psConjReal(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = claud__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = claud__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  claud__delete_buffer(buf, scanner);
  claud_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.conjreal_;
  }
}

/* Entrypoint: parse ConjString from file. */
ConjString pConjString(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = claud__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  claud_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.conjstring_;
  }
}

/* Entrypoint: parse ConjString from string. */
ConjString psConjString(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = claud__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = claud__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  claud__delete_buffer(buf, scanner);
  claud_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.conjstring_;
  }
}

/* Entrypoint: parse CONST from file. */
CONST pCONST(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = claud__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  claud_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.const_;
  }
}

/* Entrypoint: parse CONST from string. */
CONST psCONST(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = claud__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = claud__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  claud__delete_buffer(buf, scanner);
  claud_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.const_;
  }
}

/* Entrypoint: parse POINT from file. */
POINT pPOINT(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = claud__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  claud_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.point_;
  }
}

/* Entrypoint: parse POINT from string. */
POINT psPOINT(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = claud__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = claud__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  claud__delete_buffer(buf, scanner);
  claud_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.point_;
  }
}



