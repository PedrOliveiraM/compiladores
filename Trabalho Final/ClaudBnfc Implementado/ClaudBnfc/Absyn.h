/* File generated by the BNF Converter (bnfc 2.9.5). */

#ifndef ABSYN_HEADER
#define ABSYN_HEADER

/* strdup was not in the ISO C standard before 6/2019 (C2x), but in POSIX 1003.1.
 * See: https://en.cppreference.com/w/c/experimental/dynamic/strdup
 * Setting _POSIX_C_SOURCE to 200809L activates strdup in string.h.
 */
#define _POSIX_C_SOURCE 200809L

#include <stddef.h>  /* NULL */
#include <string.h>  /* strdup */

/* C++ Abstract Syntax Interface.*/

/********************   TypeDef Section    ********************/

typedef int Integer;
typedef char Char;
typedef double Double;
typedef char* String;
typedef char* Ident;

/********************   Forward Declarations    ***********************/
struct S_;
typedef struct S_ *S;

struct Block_;
typedef struct Block_ *Block;

struct CMDS_;
typedef struct CMDS_ *CMDS;

struct CMD_;
typedef struct CMD_ *CMD;

struct ATB_;
typedef struct ATB_ *ATB;

struct EXP_;
typedef struct EXP_ *EXP;

struct SE_;
typedef struct SE_ *SE;

struct OPerL_;
typedef struct OPerL_ *OPerL;

struct OPerA_;
typedef struct OPerA_ *OPerA;

struct OPL_;
typedef struct OPL_ *OPL;

struct CLAUDDIZ_;
typedef struct CLAUDDIZ_ *CLAUDDIZ;

struct RECEBA_;
typedef struct RECEBA_ *RECEBA;

struct ATE_;
typedef struct ATE_ *ATE;

struct FAZAI_;
typedef struct FAZAI_ *FAZAI;

struct VALUE_;
typedef struct VALUE_ *VALUE;

struct Type_;
typedef struct Type_ *Type;

struct VET_;
typedef struct VET_ *VET;

struct STRUCT_;
typedef struct STRUCT_ *STRUCT;

struct HeteroElements_;
typedef struct HeteroElements_ *HeteroElements;

struct HeteroElement_;
typedef struct HeteroElement_ *HeteroElement;

struct FUNC_;
typedef struct FUNC_ *FUNC;

struct GOTO_;
typedef struct GOTO_ *GOTO;

struct LABEL_;
typedef struct LABEL_ *LABEL;

struct ConjInt_;
typedef struct ConjInt_ *ConjInt;

struct ConjReal_;
typedef struct ConjReal_ *ConjReal;

struct ConjString_;
typedef struct ConjString_ *ConjString;

struct CONST_;
typedef struct CONST_ *CONST;

struct POINT_;
typedef struct POINT_ *POINT;

/********************   Abstract Syntax Classes    ********************/

struct S_
{
  enum { is_Sst } kind;
  union
  {
    struct { Block block_; } sst_;
  } u;
};

S make_Sst(Block p0);

struct Block_
{
  enum { is_LBlock } kind;
  union
  {
    struct { CMDS cmds_; } lblock_;
  } u;
};

Block make_LBlock(CMDS p0);

struct CMDS_
{
  enum { is_CMDSCMD, is_CMDS1 } kind;
  union
  {
    struct { CMD cmd_; } cmdscmd_;
    struct { CMD cmd_; CMDS cmds_; } cmds1_;
  } u;
};

CMDS make_CMDSCMD(CMD p0);
CMDS make_CMDS1(CMD p0, CMDS p1);

struct CMD_
{
  enum { is_CMDATB, is_CMDSE, is_CMDATE, is_CMDFAZAI, is_CMDCLAUDDIZ, is_CMDRECEBA, is_CMDCONST, is_CMDVET, is_CMDFUNC, is_CMDGOTO, is_CMDLABEL, is_CMDSTRUCT, is_CMDPOINT } kind;
  union
  {
    struct { ATB atb_; } cmdatb_;
    struct { SE se_; } cmdse_;
    struct { ATE ate_; } cmdate_;
    struct { FAZAI fazai_; } cmdfazai_;
    struct { CLAUDDIZ clauddiz_; } cmdclauddiz_;
    struct { RECEBA receba_; } cmdreceba_;
    struct { CONST const_; } cmdconst_;
    struct { VET vet_; } cmdvet_;
    struct { FUNC func_; } cmdfunc_;
    struct { GOTO goto_; } cmdgoto_;
    struct { LABEL label_; } cmdlabel_;
    struct { STRUCT struct_; } cmdstruct_;
    struct { POINT point_; } cmdpoint_;
  } u;
};

CMD make_CMDATB(ATB p0);
CMD make_CMDSE(SE p0);
CMD make_CMDATE(ATE p0);
CMD make_CMDFAZAI(FAZAI p0);
CMD make_CMDCLAUDDIZ(CLAUDDIZ p0);
CMD make_CMDRECEBA(RECEBA p0);
CMD make_CMDCONST(CONST p0);
CMD make_CMDVET(VET p0);
CMD make_CMDFUNC(FUNC p0);
CMD make_CMDGOTO(GOTO p0);
CMD make_CMDLABEL(LABEL p0);
CMD make_CMDSTRUCT(STRUCT p0);
CMD make_CMDPOINT(POINT p0);

struct ATB_
{
  enum { is_ATB1, is_ATB2 } kind;
  union
  {
    struct { Ident ident_; Type type_; VALUE value_; } atb1_;
    struct { EXP exp_; Ident ident_; Type type_; } atb2_;
  } u;
};

ATB make_ATB1(Type p0, Ident p1, VALUE p2);
ATB make_ATB2(Type p0, Ident p1, EXP p2);

struct EXP_
{
  enum { is_EXP1, is_EXP2 } kind;
  union
  {
    struct { OPerA opera_; VALUE value_1, value_2; } exp1_;
    struct { EXP exp_; OPerA opera_; VALUE value_; } exp2_;
  } u;
};

EXP make_EXP1(VALUE p0, OPerA p1, VALUE p2);
EXP make_EXP2(EXP p0, OPerA p1, VALUE p2);

struct SE_
{
  enum { is_SE1, is_SE2 } kind;
  union
  {
    struct { Block block_; OPL opl_; } se1_;
    struct { Block block_1, block_2; OPL opl_; } se2_;
  } u;
};

SE make_SE1(OPL p0, Block p1);
SE make_SE2(OPL p0, Block p1, Block p2);

struct OPerL_
{
  enum { is_OPerL1, is_OPerL2, is_OPerL3, is_OPerL4, is_OPerL5, is_OPerL6 } kind;
  union
  {
  } u;
};

OPerL make_OPerL1(void);
OPerL make_OPerL2(void);
OPerL make_OPerL3(void);
OPerL make_OPerL4(void);
OPerL make_OPerL5(void);
OPerL make_OPerL6(void);

struct OPerA_
{
  enum { is_OPerA1, is_OPerA2, is_OPerA3, is_OPerA4 } kind;
  union
  {
  } u;
};

OPerA make_OPerA1(void);
OPerA make_OPerA2(void);
OPerA make_OPerA3(void);
OPerA make_OPerA4(void);

struct OPL_
{
  enum { is_OPL1 } kind;
  union
  {
    struct { OPerL operl_; VALUE value_1, value_2; } opl1_;
  } u;
};

OPL make_OPL1(VALUE p0, OPerL p1, VALUE p2);

struct CLAUDDIZ_
{
  enum { is_CLAUDDIZ1 } kind;
  union
  {
    struct { VALUE value_; } clauddiz1_;
  } u;
};

CLAUDDIZ make_CLAUDDIZ1(VALUE p0);

struct RECEBA_
{
  enum { is_RECEBA1 } kind;
  union
  {
    struct { Ident ident_; Type type_; } receba1_;
  } u;
};

RECEBA make_RECEBA1(Type p0, Ident p1);

struct ATE_
{
  enum { is_ATE1 } kind;
  union
  {
    struct { Block block_; OPL opl_; } ate1_;
  } u;
};

ATE make_ATE1(OPL p0, Block p1);

struct FAZAI_
{
  enum { is_FAZAI1 } kind;
  union
  {
    struct { Block block_; Ident ident_; Integer integer_; OPL opl_; Type type_; VALUE value_; } fazai1_;
  } u;
};

FAZAI make_FAZAI1(Type p0, Ident p1, VALUE p2, OPL p3, Integer p4, Block p5);

struct VALUE_
{
  enum { is_VALUEIdent, is_VALUEString, is_VALUEInteger, is_VALUEDouble } kind;
  union
  {
    struct { Ident ident_; } valueident_;
    struct { String string_; } valuestring_;
    struct { Integer integer_; } valueinteger_;
    struct { Double double_; } valuedouble_;
  } u;
};

VALUE make_VALUEIdent(Ident p0);
VALUE make_VALUEString(String p0);
VALUE make_VALUEInteger(Integer p0);
VALUE make_VALUEDouble(Double p0);

struct Type_
{
  enum { is_Type_interu, is_Type_floaty, is_Type_stringo } kind;
  union
  {
  } u;
};

Type make_Type_interu(void);
Type make_Type_floaty(void);
Type make_Type_stringo(void);

struct VET_
{
  enum { is_VET1, is_VET2, is_VET3, is_VET4 } kind;
  union
  {
    struct { Ident ident_; Integer integer_; Type type_; } vet1_;
    struct { ConjInt conjint_; Ident ident_; Integer integer_; } vet2_;
    struct { ConjReal conjreal_; Ident ident_; Integer integer_; } vet3_;
    struct { ConjString conjstring_; Ident ident_; Integer integer_; } vet4_;
  } u;
};

VET make_VET1(Type p0, Ident p1, Integer p2);
VET make_VET2(Ident p0, Integer p1, ConjInt p2);
VET make_VET3(Ident p0, Integer p1, ConjReal p2);
VET make_VET4(Ident p0, Integer p1, ConjString p2);

struct STRUCT_
{
  enum { is_STRUCT1 } kind;
  union
  {
    struct { HeteroElements heteroelements_; Integer integer_; } struct1_;
  } u;
};

STRUCT make_STRUCT1(Integer p0, HeteroElements p1);

struct HeteroElements_
{
  enum { is_HeteroElementsHeteroElement, is_HeteroElements1 } kind;
  union
  {
    struct { HeteroElement heteroelement_; } heteroelementsheteroelement_;
    struct { HeteroElement heteroelement_; HeteroElements heteroelements_; } heteroelements1_;
  } u;
};

HeteroElements make_HeteroElementsHeteroElement(HeteroElement p0);
HeteroElements make_HeteroElements1(HeteroElement p0, HeteroElements p1);

struct HeteroElement_
{
  enum { is_HeteroElementString, is_HeteroElementDouble, is_HeteroElementInteger } kind;
  union
  {
    struct { String string_; } heteroelementstring_;
    struct { Double double_; } heteroelementdouble_;
    struct { Integer integer_; } heteroelementinteger_;
  } u;
};

HeteroElement make_HeteroElementString(String p0);
HeteroElement make_HeteroElementDouble(Double p0);
HeteroElement make_HeteroElementInteger(Integer p0);

struct FUNC_
{
  enum { is_FUNC1 } kind;
  union
  {
    struct { Block block_; Ident ident_; } func1_;
  } u;
};

FUNC make_FUNC1(Ident p0, Block p1);

struct GOTO_
{
  enum { is_GOTO1 } kind;
  union
  {
    struct { Integer integer_; } goto1_;
  } u;
};

GOTO make_GOTO1(Integer p0);

struct LABEL_
{
  enum { is_LABEL1 } kind;
  union
  {
    struct { Block block_; Integer integer_; } label1_;
  } u;
};

LABEL make_LABEL1(Integer p0, Block p1);

struct ConjInt_
{
  enum { is_ConjIntInteger, is_ConjInt1 } kind;
  union
  {
    struct { Integer integer_; } conjintinteger_;
    struct { ConjInt conjint_; Integer integer_; } conjint1_;
  } u;
};

ConjInt make_ConjIntInteger(Integer p0);
ConjInt make_ConjInt1(Integer p0, ConjInt p1);

struct ConjReal_
{
  enum { is_ConjRealDouble, is_ConjReal1 } kind;
  union
  {
    struct { Double double_; } conjrealdouble_;
    struct { ConjReal conjreal_; Double double_; } conjreal1_;
  } u;
};

ConjReal make_ConjRealDouble(Double p0);
ConjReal make_ConjReal1(Double p0, ConjReal p1);

struct ConjString_
{
  enum { is_ConjStringString, is_ConjString1 } kind;
  union
  {
    struct { String string_; } conjstringstring_;
    struct { ConjString conjstring_; String string_; } conjstring1_;
  } u;
};

ConjString make_ConjStringString(String p0);
ConjString make_ConjString1(String p0, ConjString p1);

struct CONST_
{
  enum { is_LConst } kind;
  union
  {
    struct { Ident ident_; Type type_; VALUE value_; } lconst_;
  } u;
};

CONST make_LConst(Type p0, Ident p1, VALUE p2);

struct POINT_
{
  enum { is_LPoint } kind;
  union
  {
    struct { Ident ident_1, ident_2; Type type_; } lpoint_;
  } u;
};

POINT make_LPoint(Type p0, Ident p1, Ident p2);

/***************************   Cloning   ******************************/

S clone_S(S p);
Block clone_Block(Block p);
CMDS clone_CMDS(CMDS p);
CMD clone_CMD(CMD p);
ATB clone_ATB(ATB p);
EXP clone_EXP(EXP p);
SE clone_SE(SE p);
OPerL clone_OPerL(OPerL p);
OPerA clone_OPerA(OPerA p);
OPL clone_OPL(OPL p);
CLAUDDIZ clone_CLAUDDIZ(CLAUDDIZ p);
RECEBA clone_RECEBA(RECEBA p);
ATE clone_ATE(ATE p);
FAZAI clone_FAZAI(FAZAI p);
VALUE clone_VALUE(VALUE p);
Type clone_Type(Type p);
VET clone_VET(VET p);
STRUCT clone_STRUCT(STRUCT p);
HeteroElements clone_HeteroElements(HeteroElements p);
HeteroElement clone_HeteroElement(HeteroElement p);
FUNC clone_FUNC(FUNC p);
GOTO clone_GOTO(GOTO p);
LABEL clone_LABEL(LABEL p);
ConjInt clone_ConjInt(ConjInt p);
ConjReal clone_ConjReal(ConjReal p);
ConjString clone_ConjString(ConjString p);
CONST clone_CONST(CONST p);
POINT clone_POINT(POINT p);

/********************   Recursive Destructors    **********************/

/* These free an entire abstract syntax tree
 * including all subtrees and strings.
 *
 * Will not work properly if there is sharing in the tree,
 * i.e., when some pointers are aliased.  In this case
 * it will attempt to free the same memory twice.
 */

void free_S(S p);
void free_Block(Block p);
void free_CMDS(CMDS p);
void free_CMD(CMD p);
void free_ATB(ATB p);
void free_EXP(EXP p);
void free_SE(SE p);
void free_OPerL(OPerL p);
void free_OPerA(OPerA p);
void free_OPL(OPL p);
void free_CLAUDDIZ(CLAUDDIZ p);
void free_RECEBA(RECEBA p);
void free_ATE(ATE p);
void free_FAZAI(FAZAI p);
void free_VALUE(VALUE p);
void free_Type(Type p);
void free_VET(VET p);
void free_STRUCT(STRUCT p);
void free_HeteroElements(HeteroElements p);
void free_HeteroElement(HeteroElement p);
void free_FUNC(FUNC p);
void free_GOTO(GOTO p);
void free_LABEL(LABEL p);
void free_ConjInt(ConjInt p);
void free_ConjReal(ConjReal p);
void free_ConjString(ConjString p);
void free_CONST(CONST p);
void free_POINT(POINT p);


#endif
