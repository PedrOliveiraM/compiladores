/* File generated by the BNF Converter (bnfc 2.9.5). */

/* C Abstract Syntax Implementation. */

#include <stdio.h>
#include <stdlib.h>
#include "Absyn.h"

/********************   Sst    ********************/

S make_Sst(Block p1)
{
    S tmp = (S) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Sst!\n");
        exit(1);
    }
    tmp->kind = is_Sst;
    tmp->u.sst_.block_ = p1;
    return tmp;
}

/********************   LBlock    ********************/

Block make_LBlock(CMDS p1)
{
    Block tmp = (Block) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating LBlock!\n");
        exit(1);
    }
    tmp->kind = is_LBlock;
    tmp->u.lblock_.cmds_ = p1;
    return tmp;
}

/********************   CMDSCMD    ********************/

CMDS make_CMDSCMD(CMD p1)
{
    CMDS tmp = (CMDS) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating CMDSCMD!\n");
        exit(1);
    }
    tmp->kind = is_CMDSCMD;
    tmp->u.cmdscmd_.cmd_ = p1;
    return tmp;
}

/********************   CMDS1    ********************/

CMDS make_CMDS1(CMD p1, CMDS p2)
{
    CMDS tmp = (CMDS) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating CMDS1!\n");
        exit(1);
    }
    tmp->kind = is_CMDS1;
    tmp->u.cmds1_.cmd_ = p1;
    tmp->u.cmds1_.cmds_ = p2;
    return tmp;
}

/********************   CMDATB    ********************/

CMD make_CMDATB(ATB p1)
{
    CMD tmp = (CMD) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating CMDATB!\n");
        exit(1);
    }
    tmp->kind = is_CMDATB;
    tmp->u.cmdatb_.atb_ = p1;
    return tmp;
}

/********************   CMDSE    ********************/

CMD make_CMDSE(SE p1)
{
    CMD tmp = (CMD) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating CMDSE!\n");
        exit(1);
    }
    tmp->kind = is_CMDSE;
    tmp->u.cmdse_.se_ = p1;
    return tmp;
}

/********************   CMDATE    ********************/

CMD make_CMDATE(ATE p1)
{
    CMD tmp = (CMD) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating CMDATE!\n");
        exit(1);
    }
    tmp->kind = is_CMDATE;
    tmp->u.cmdate_.ate_ = p1;
    return tmp;
}

/********************   CMDFAZAI    ********************/

CMD make_CMDFAZAI(FAZAI p1)
{
    CMD tmp = (CMD) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating CMDFAZAI!\n");
        exit(1);
    }
    tmp->kind = is_CMDFAZAI;
    tmp->u.cmdfazai_.fazai_ = p1;
    return tmp;
}

/********************   CMDCLAUDDIZ    ********************/

CMD make_CMDCLAUDDIZ(CLAUDDIZ p1)
{
    CMD tmp = (CMD) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating CMDCLAUDDIZ!\n");
        exit(1);
    }
    tmp->kind = is_CMDCLAUDDIZ;
    tmp->u.cmdclauddiz_.clauddiz_ = p1;
    return tmp;
}

/********************   CMDRECEBA    ********************/

CMD make_CMDRECEBA(RECEBA p1)
{
    CMD tmp = (CMD) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating CMDRECEBA!\n");
        exit(1);
    }
    tmp->kind = is_CMDRECEBA;
    tmp->u.cmdreceba_.receba_ = p1;
    return tmp;
}

/********************   CMDCONST    ********************/

CMD make_CMDCONST(CONST p1)
{
    CMD tmp = (CMD) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating CMDCONST!\n");
        exit(1);
    }
    tmp->kind = is_CMDCONST;
    tmp->u.cmdconst_.const_ = p1;
    return tmp;
}

/********************   CMDVET    ********************/

CMD make_CMDVET(VET p1)
{
    CMD tmp = (CMD) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating CMDVET!\n");
        exit(1);
    }
    tmp->kind = is_CMDVET;
    tmp->u.cmdvet_.vet_ = p1;
    return tmp;
}

/********************   CMDFUNC    ********************/

CMD make_CMDFUNC(FUNC p1)
{
    CMD tmp = (CMD) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating CMDFUNC!\n");
        exit(1);
    }
    tmp->kind = is_CMDFUNC;
    tmp->u.cmdfunc_.func_ = p1;
    return tmp;
}

/********************   CMDGOTO    ********************/

CMD make_CMDGOTO(GOTO p1)
{
    CMD tmp = (CMD) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating CMDGOTO!\n");
        exit(1);
    }
    tmp->kind = is_CMDGOTO;
    tmp->u.cmdgoto_.goto_ = p1;
    return tmp;
}

/********************   CMDLABEL    ********************/

CMD make_CMDLABEL(LABEL p1)
{
    CMD tmp = (CMD) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating CMDLABEL!\n");
        exit(1);
    }
    tmp->kind = is_CMDLABEL;
    tmp->u.cmdlabel_.label_ = p1;
    return tmp;
}

/********************   CMDSTRUCT    ********************/

CMD make_CMDSTRUCT(STRUCT p1)
{
    CMD tmp = (CMD) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating CMDSTRUCT!\n");
        exit(1);
    }
    tmp->kind = is_CMDSTRUCT;
    tmp->u.cmdstruct_.struct_ = p1;
    return tmp;
}

/********************   CMDPOINT    ********************/

CMD make_CMDPOINT(POINT p1)
{
    CMD tmp = (CMD) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating CMDPOINT!\n");
        exit(1);
    }
    tmp->kind = is_CMDPOINT;
    tmp->u.cmdpoint_.point_ = p1;
    return tmp;
}

/********************   ATB1    ********************/

ATB make_ATB1(Type p1, Ident p2, VALUE p3)
{
    ATB tmp = (ATB) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating ATB1!\n");
        exit(1);
    }
    tmp->kind = is_ATB1;
    tmp->u.atb1_.type_ = p1;
    tmp->u.atb1_.ident_ = p2;
    tmp->u.atb1_.value_ = p3;
    return tmp;
}

/********************   ATB2    ********************/

ATB make_ATB2(Type p1, Ident p2, EXP p3)
{
    ATB tmp = (ATB) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating ATB2!\n");
        exit(1);
    }
    tmp->kind = is_ATB2;
    tmp->u.atb2_.type_ = p1;
    tmp->u.atb2_.ident_ = p2;
    tmp->u.atb2_.exp_ = p3;
    return tmp;
}

/********************   EXP1    ********************/

EXP make_EXP1(VALUE p1, OPerA p2, VALUE p3)
{
    EXP tmp = (EXP) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating EXP1!\n");
        exit(1);
    }
    tmp->kind = is_EXP1;
    tmp->u.exp1_.value_1 = p1;
    tmp->u.exp1_.opera_ = p2;
    tmp->u.exp1_.value_2 = p3;
    return tmp;
}

/********************   EXP2    ********************/

EXP make_EXP2(EXP p1, OPerA p2, VALUE p3)
{
    EXP tmp = (EXP) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating EXP2!\n");
        exit(1);
    }
    tmp->kind = is_EXP2;
    tmp->u.exp2_.exp_ = p1;
    tmp->u.exp2_.opera_ = p2;
    tmp->u.exp2_.value_ = p3;
    return tmp;
}

/********************   SE1    ********************/

SE make_SE1(OPL p1, Block p2)
{
    SE tmp = (SE) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating SE1!\n");
        exit(1);
    }
    tmp->kind = is_SE1;
    tmp->u.se1_.opl_ = p1;
    tmp->u.se1_.block_ = p2;
    return tmp;
}

/********************   SE2    ********************/

SE make_SE2(OPL p1, Block p2, Block p3)
{
    SE tmp = (SE) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating SE2!\n");
        exit(1);
    }
    tmp->kind = is_SE2;
    tmp->u.se2_.opl_ = p1;
    tmp->u.se2_.block_1 = p2;
    tmp->u.se2_.block_2 = p3;
    return tmp;
}

/********************   OPerL1    ********************/

OPerL make_OPerL1()
{
    OPerL tmp = (OPerL) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating OPerL1!\n");
        exit(1);
    }
    tmp->kind = is_OPerL1;
    return tmp;
}

/********************   OPerL2    ********************/

OPerL make_OPerL2()
{
    OPerL tmp = (OPerL) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating OPerL2!\n");
        exit(1);
    }
    tmp->kind = is_OPerL2;
    return tmp;
}

/********************   OPerL3    ********************/

OPerL make_OPerL3()
{
    OPerL tmp = (OPerL) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating OPerL3!\n");
        exit(1);
    }
    tmp->kind = is_OPerL3;
    return tmp;
}

/********************   OPerL4    ********************/

OPerL make_OPerL4()
{
    OPerL tmp = (OPerL) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating OPerL4!\n");
        exit(1);
    }
    tmp->kind = is_OPerL4;
    return tmp;
}

/********************   OPerL5    ********************/

OPerL make_OPerL5()
{
    OPerL tmp = (OPerL) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating OPerL5!\n");
        exit(1);
    }
    tmp->kind = is_OPerL5;
    return tmp;
}

/********************   OPerL6    ********************/

OPerL make_OPerL6()
{
    OPerL tmp = (OPerL) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating OPerL6!\n");
        exit(1);
    }
    tmp->kind = is_OPerL6;
    return tmp;
}

/********************   OPerA1    ********************/

OPerA make_OPerA1()
{
    OPerA tmp = (OPerA) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating OPerA1!\n");
        exit(1);
    }
    tmp->kind = is_OPerA1;
    return tmp;
}

/********************   OPerA2    ********************/

OPerA make_OPerA2()
{
    OPerA tmp = (OPerA) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating OPerA2!\n");
        exit(1);
    }
    tmp->kind = is_OPerA2;
    return tmp;
}

/********************   OPerA3    ********************/

OPerA make_OPerA3()
{
    OPerA tmp = (OPerA) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating OPerA3!\n");
        exit(1);
    }
    tmp->kind = is_OPerA3;
    return tmp;
}

/********************   OPerA4    ********************/

OPerA make_OPerA4()
{
    OPerA tmp = (OPerA) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating OPerA4!\n");
        exit(1);
    }
    tmp->kind = is_OPerA4;
    return tmp;
}

/********************   OPL1    ********************/

OPL make_OPL1(VALUE p1, OPerL p2, VALUE p3)
{
    OPL tmp = (OPL) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating OPL1!\n");
        exit(1);
    }
    tmp->kind = is_OPL1;
    tmp->u.opl1_.value_1 = p1;
    tmp->u.opl1_.operl_ = p2;
    tmp->u.opl1_.value_2 = p3;
    return tmp;
}

/********************   CLAUDDIZ1    ********************/

CLAUDDIZ make_CLAUDDIZ1(VALUE p1)
{
    CLAUDDIZ tmp = (CLAUDDIZ) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating CLAUDDIZ1!\n");
        exit(1);
    }
    tmp->kind = is_CLAUDDIZ1;
    tmp->u.clauddiz1_.value_ = p1;
    return tmp;
}

/********************   RECEBA1    ********************/

RECEBA make_RECEBA1(Type p1, Ident p2)
{
    RECEBA tmp = (RECEBA) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating RECEBA1!\n");
        exit(1);
    }
    tmp->kind = is_RECEBA1;
    tmp->u.receba1_.type_ = p1;
    tmp->u.receba1_.ident_ = p2;
    return tmp;
}

/********************   ATE1    ********************/

ATE make_ATE1(OPL p1, Block p2)
{
    ATE tmp = (ATE) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating ATE1!\n");
        exit(1);
    }
    tmp->kind = is_ATE1;
    tmp->u.ate1_.opl_ = p1;
    tmp->u.ate1_.block_ = p2;
    return tmp;
}

/********************   FAZAI1    ********************/

FAZAI make_FAZAI1(Type p1, Ident p2, VALUE p3, OPL p4, Integer p5, Block p6)
{
    FAZAI tmp = (FAZAI) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating FAZAI1!\n");
        exit(1);
    }
    tmp->kind = is_FAZAI1;
    tmp->u.fazai1_.type_ = p1;
    tmp->u.fazai1_.ident_ = p2;
    tmp->u.fazai1_.value_ = p3;
    tmp->u.fazai1_.opl_ = p4;
    tmp->u.fazai1_.integer_ = p5;
    tmp->u.fazai1_.block_ = p6;
    return tmp;
}

/********************   VALUEIdent    ********************/

VALUE make_VALUEIdent(Ident p1)
{
    VALUE tmp = (VALUE) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating VALUEIdent!\n");
        exit(1);
    }
    tmp->kind = is_VALUEIdent;
    tmp->u.valueident_.ident_ = p1;
    return tmp;
}

/********************   VALUEString    ********************/

VALUE make_VALUEString(String p1)
{
    VALUE tmp = (VALUE) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating VALUEString!\n");
        exit(1);
    }
    tmp->kind = is_VALUEString;
    tmp->u.valuestring_.string_ = p1;
    return tmp;
}

/********************   VALUEInteger    ********************/

VALUE make_VALUEInteger(Integer p1)
{
    VALUE tmp = (VALUE) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating VALUEInteger!\n");
        exit(1);
    }
    tmp->kind = is_VALUEInteger;
    tmp->u.valueinteger_.integer_ = p1;
    return tmp;
}

/********************   VALUEDouble    ********************/

VALUE make_VALUEDouble(Double p1)
{
    VALUE tmp = (VALUE) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating VALUEDouble!\n");
        exit(1);
    }
    tmp->kind = is_VALUEDouble;
    tmp->u.valuedouble_.double_ = p1;
    return tmp;
}

/********************   Type_interu    ********************/

Type make_Type_interu()
{
    Type tmp = (Type) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Type_interu!\n");
        exit(1);
    }
    tmp->kind = is_Type_interu;
    return tmp;
}

/********************   Type_floaty    ********************/

Type make_Type_floaty()
{
    Type tmp = (Type) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Type_floaty!\n");
        exit(1);
    }
    tmp->kind = is_Type_floaty;
    return tmp;
}

/********************   Type_stringo    ********************/

Type make_Type_stringo()
{
    Type tmp = (Type) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Type_stringo!\n");
        exit(1);
    }
    tmp->kind = is_Type_stringo;
    return tmp;
}

/********************   VET1    ********************/

VET make_VET1(Type p1, Ident p2, Integer p3)
{
    VET tmp = (VET) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating VET1!\n");
        exit(1);
    }
    tmp->kind = is_VET1;
    tmp->u.vet1_.type_ = p1;
    tmp->u.vet1_.ident_ = p2;
    tmp->u.vet1_.integer_ = p3;
    return tmp;
}

/********************   VET2    ********************/

VET make_VET2(Ident p1, Integer p2, ConjInt p3)
{
    VET tmp = (VET) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating VET2!\n");
        exit(1);
    }
    tmp->kind = is_VET2;
    tmp->u.vet2_.ident_ = p1;
    tmp->u.vet2_.integer_ = p2;
    tmp->u.vet2_.conjint_ = p3;
    return tmp;
}

/********************   VET3    ********************/

VET make_VET3(Ident p1, Integer p2, ConjReal p3)
{
    VET tmp = (VET) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating VET3!\n");
        exit(1);
    }
    tmp->kind = is_VET3;
    tmp->u.vet3_.ident_ = p1;
    tmp->u.vet3_.integer_ = p2;
    tmp->u.vet3_.conjreal_ = p3;
    return tmp;
}

/********************   VET4    ********************/

VET make_VET4(Ident p1, Integer p2, ConjString p3)
{
    VET tmp = (VET) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating VET4!\n");
        exit(1);
    }
    tmp->kind = is_VET4;
    tmp->u.vet4_.ident_ = p1;
    tmp->u.vet4_.integer_ = p2;
    tmp->u.vet4_.conjstring_ = p3;
    return tmp;
}

/********************   STRUCT1    ********************/

STRUCT make_STRUCT1(Integer p1, HeteroElements p2)
{
    STRUCT tmp = (STRUCT) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating STRUCT1!\n");
        exit(1);
    }
    tmp->kind = is_STRUCT1;
    tmp->u.struct1_.integer_ = p1;
    tmp->u.struct1_.heteroelements_ = p2;
    return tmp;
}

/********************   HeteroElementsHeteroElement    ********************/

HeteroElements make_HeteroElementsHeteroElement(HeteroElement p1)
{
    HeteroElements tmp = (HeteroElements) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating HeteroElementsHeteroElement!\n");
        exit(1);
    }
    tmp->kind = is_HeteroElementsHeteroElement;
    tmp->u.heteroelementsheteroelement_.heteroelement_ = p1;
    return tmp;
}

/********************   HeteroElements1    ********************/

HeteroElements make_HeteroElements1(HeteroElement p1, HeteroElements p2)
{
    HeteroElements tmp = (HeteroElements) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating HeteroElements1!\n");
        exit(1);
    }
    tmp->kind = is_HeteroElements1;
    tmp->u.heteroelements1_.heteroelement_ = p1;
    tmp->u.heteroelements1_.heteroelements_ = p2;
    return tmp;
}

/********************   HeteroElementString    ********************/

HeteroElement make_HeteroElementString(String p1)
{
    HeteroElement tmp = (HeteroElement) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating HeteroElementString!\n");
        exit(1);
    }
    tmp->kind = is_HeteroElementString;
    tmp->u.heteroelementstring_.string_ = p1;
    return tmp;
}

/********************   HeteroElementDouble    ********************/

HeteroElement make_HeteroElementDouble(Double p1)
{
    HeteroElement tmp = (HeteroElement) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating HeteroElementDouble!\n");
        exit(1);
    }
    tmp->kind = is_HeteroElementDouble;
    tmp->u.heteroelementdouble_.double_ = p1;
    return tmp;
}

/********************   HeteroElementInteger    ********************/

HeteroElement make_HeteroElementInteger(Integer p1)
{
    HeteroElement tmp = (HeteroElement) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating HeteroElementInteger!\n");
        exit(1);
    }
    tmp->kind = is_HeteroElementInteger;
    tmp->u.heteroelementinteger_.integer_ = p1;
    return tmp;
}

/********************   FUNC1    ********************/

FUNC make_FUNC1(Ident p1, Block p2)
{
    FUNC tmp = (FUNC) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating FUNC1!\n");
        exit(1);
    }
    tmp->kind = is_FUNC1;
    tmp->u.func1_.ident_ = p1;
    tmp->u.func1_.block_ = p2;
    return tmp;
}

/********************   GOTO1    ********************/

GOTO make_GOTO1(Integer p1)
{
    GOTO tmp = (GOTO) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating GOTO1!\n");
        exit(1);
    }
    tmp->kind = is_GOTO1;
    tmp->u.goto1_.integer_ = p1;
    return tmp;
}

/********************   LABEL1    ********************/

LABEL make_LABEL1(Integer p1, Block p2)
{
    LABEL tmp = (LABEL) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating LABEL1!\n");
        exit(1);
    }
    tmp->kind = is_LABEL1;
    tmp->u.label1_.integer_ = p1;
    tmp->u.label1_.block_ = p2;
    return tmp;
}

/********************   ConjIntInteger    ********************/

ConjInt make_ConjIntInteger(Integer p1)
{
    ConjInt tmp = (ConjInt) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating ConjIntInteger!\n");
        exit(1);
    }
    tmp->kind = is_ConjIntInteger;
    tmp->u.conjintinteger_.integer_ = p1;
    return tmp;
}

/********************   ConjInt1    ********************/

ConjInt make_ConjInt1(Integer p1, ConjInt p2)
{
    ConjInt tmp = (ConjInt) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating ConjInt1!\n");
        exit(1);
    }
    tmp->kind = is_ConjInt1;
    tmp->u.conjint1_.integer_ = p1;
    tmp->u.conjint1_.conjint_ = p2;
    return tmp;
}

/********************   ConjRealDouble    ********************/

ConjReal make_ConjRealDouble(Double p1)
{
    ConjReal tmp = (ConjReal) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating ConjRealDouble!\n");
        exit(1);
    }
    tmp->kind = is_ConjRealDouble;
    tmp->u.conjrealdouble_.double_ = p1;
    return tmp;
}

/********************   ConjReal1    ********************/

ConjReal make_ConjReal1(Double p1, ConjReal p2)
{
    ConjReal tmp = (ConjReal) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating ConjReal1!\n");
        exit(1);
    }
    tmp->kind = is_ConjReal1;
    tmp->u.conjreal1_.double_ = p1;
    tmp->u.conjreal1_.conjreal_ = p2;
    return tmp;
}

/********************   ConjStringString    ********************/

ConjString make_ConjStringString(String p1)
{
    ConjString tmp = (ConjString) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating ConjStringString!\n");
        exit(1);
    }
    tmp->kind = is_ConjStringString;
    tmp->u.conjstringstring_.string_ = p1;
    return tmp;
}

/********************   ConjString1    ********************/

ConjString make_ConjString1(String p1, ConjString p2)
{
    ConjString tmp = (ConjString) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating ConjString1!\n");
        exit(1);
    }
    tmp->kind = is_ConjString1;
    tmp->u.conjstring1_.string_ = p1;
    tmp->u.conjstring1_.conjstring_ = p2;
    return tmp;
}

/********************   LConst    ********************/

CONST make_LConst(Type p1, Ident p2, VALUE p3)
{
    CONST tmp = (CONST) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating LConst!\n");
        exit(1);
    }
    tmp->kind = is_LConst;
    tmp->u.lconst_.type_ = p1;
    tmp->u.lconst_.ident_ = p2;
    tmp->u.lconst_.value_ = p3;
    return tmp;
}

/********************   LPoint    ********************/

POINT make_LPoint(Type p1, Ident p2, Ident p3)
{
    POINT tmp = (POINT) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating LPoint!\n");
        exit(1);
    }
    tmp->kind = is_LPoint;
    tmp->u.lpoint_.type_ = p1;
    tmp->u.lpoint_.ident_1 = p2;
    tmp->u.lpoint_.ident_2 = p3;
    return tmp;
}

/***************************   Cloning   ******************************/

S clone_S(S p)
{
  switch(p->kind)
  {
  case is_Sst:
    return make_Sst (clone_Block(p->u.sst_.block_));

  default:
    fprintf(stderr, "Error: bad kind field when cloning S!\n");
    exit(1);
  }
}

Block clone_Block(Block p)
{
  switch(p->kind)
  {
  case is_LBlock:
    return make_LBlock (clone_CMDS(p->u.lblock_.cmds_));

  default:
    fprintf(stderr, "Error: bad kind field when cloning Block!\n");
    exit(1);
  }
}

CMDS clone_CMDS(CMDS p)
{
  switch(p->kind)
  {
  case is_CMDSCMD:
    return make_CMDSCMD (clone_CMD(p->u.cmdscmd_.cmd_));

  case is_CMDS1:
    return make_CMDS1
      ( clone_CMD(p->u.cmds1_.cmd_)
      , clone_CMDS(p->u.cmds1_.cmds_)
      );

  default:
    fprintf(stderr, "Error: bad kind field when cloning CMDS!\n");
    exit(1);
  }
}

CMD clone_CMD(CMD p)
{
  switch(p->kind)
  {
  case is_CMDATB:
    return make_CMDATB (clone_ATB(p->u.cmdatb_.atb_));

  case is_CMDSE:
    return make_CMDSE (clone_SE(p->u.cmdse_.se_));

  case is_CMDATE:
    return make_CMDATE (clone_ATE(p->u.cmdate_.ate_));

  case is_CMDFAZAI:
    return make_CMDFAZAI (clone_FAZAI(p->u.cmdfazai_.fazai_));

  case is_CMDCLAUDDIZ:
    return make_CMDCLAUDDIZ (clone_CLAUDDIZ(p->u.cmdclauddiz_.clauddiz_));

  case is_CMDRECEBA:
    return make_CMDRECEBA (clone_RECEBA(p->u.cmdreceba_.receba_));

  case is_CMDCONST:
    return make_CMDCONST (clone_CONST(p->u.cmdconst_.const_));

  case is_CMDVET:
    return make_CMDVET (clone_VET(p->u.cmdvet_.vet_));

  case is_CMDFUNC:
    return make_CMDFUNC (clone_FUNC(p->u.cmdfunc_.func_));

  case is_CMDGOTO:
    return make_CMDGOTO (clone_GOTO(p->u.cmdgoto_.goto_));

  case is_CMDLABEL:
    return make_CMDLABEL (clone_LABEL(p->u.cmdlabel_.label_));

  case is_CMDSTRUCT:
    return make_CMDSTRUCT (clone_STRUCT(p->u.cmdstruct_.struct_));

  case is_CMDPOINT:
    return make_CMDPOINT (clone_POINT(p->u.cmdpoint_.point_));

  default:
    fprintf(stderr, "Error: bad kind field when cloning CMD!\n");
    exit(1);
  }
}

ATB clone_ATB(ATB p)
{
  switch(p->kind)
  {
  case is_ATB1:
    return make_ATB1
      ( clone_Type(p->u.atb1_.type_)
      , strdup(p->u.atb1_.ident_)
      , clone_VALUE(p->u.atb1_.value_)
      );

  case is_ATB2:
    return make_ATB2
      ( clone_Type(p->u.atb2_.type_)
      , strdup(p->u.atb2_.ident_)
      , clone_EXP(p->u.atb2_.exp_)
      );

  default:
    fprintf(stderr, "Error: bad kind field when cloning ATB!\n");
    exit(1);
  }
}

EXP clone_EXP(EXP p)
{
  switch(p->kind)
  {
  case is_EXP1:
    return make_EXP1
      ( clone_VALUE(p->u.exp1_.value_1)
      , clone_OPerA(p->u.exp1_.opera_)
      , clone_VALUE(p->u.exp1_.value_2)
      );

  case is_EXP2:
    return make_EXP2
      ( clone_EXP(p->u.exp2_.exp_)
      , clone_OPerA(p->u.exp2_.opera_)
      , clone_VALUE(p->u.exp2_.value_)
      );

  default:
    fprintf(stderr, "Error: bad kind field when cloning EXP!\n");
    exit(1);
  }
}

SE clone_SE(SE p)
{
  switch(p->kind)
  {
  case is_SE1:
    return make_SE1
      ( clone_OPL(p->u.se1_.opl_)
      , clone_Block(p->u.se1_.block_)
      );

  case is_SE2:
    return make_SE2
      ( clone_OPL(p->u.se2_.opl_)
      , clone_Block(p->u.se2_.block_1)
      , clone_Block(p->u.se2_.block_2)
      );

  default:
    fprintf(stderr, "Error: bad kind field when cloning SE!\n");
    exit(1);
  }
}

OPerL clone_OPerL(OPerL p)
{
  switch(p->kind)
  {
  case is_OPerL1:
    return make_OPerL1 ();

  case is_OPerL2:
    return make_OPerL2 ();

  case is_OPerL3:
    return make_OPerL3 ();

  case is_OPerL4:
    return make_OPerL4 ();

  case is_OPerL5:
    return make_OPerL5 ();

  case is_OPerL6:
    return make_OPerL6 ();

  default:
    fprintf(stderr, "Error: bad kind field when cloning OPerL!\n");
    exit(1);
  }
}

OPerA clone_OPerA(OPerA p)
{
  switch(p->kind)
  {
  case is_OPerA1:
    return make_OPerA1 ();

  case is_OPerA2:
    return make_OPerA2 ();

  case is_OPerA3:
    return make_OPerA3 ();

  case is_OPerA4:
    return make_OPerA4 ();

  default:
    fprintf(stderr, "Error: bad kind field when cloning OPerA!\n");
    exit(1);
  }
}

OPL clone_OPL(OPL p)
{
  switch(p->kind)
  {
  case is_OPL1:
    return make_OPL1
      ( clone_VALUE(p->u.opl1_.value_1)
      , clone_OPerL(p->u.opl1_.operl_)
      , clone_VALUE(p->u.opl1_.value_2)
      );

  default:
    fprintf(stderr, "Error: bad kind field when cloning OPL!\n");
    exit(1);
  }
}

CLAUDDIZ clone_CLAUDDIZ(CLAUDDIZ p)
{
  switch(p->kind)
  {
  case is_CLAUDDIZ1:
    return make_CLAUDDIZ1 (clone_VALUE(p->u.clauddiz1_.value_));

  default:
    fprintf(stderr, "Error: bad kind field when cloning CLAUDDIZ!\n");
    exit(1);
  }
}

RECEBA clone_RECEBA(RECEBA p)
{
  switch(p->kind)
  {
  case is_RECEBA1:
    return make_RECEBA1
      ( clone_Type(p->u.receba1_.type_)
      , strdup(p->u.receba1_.ident_)
      );

  default:
    fprintf(stderr, "Error: bad kind field when cloning RECEBA!\n");
    exit(1);
  }
}

ATE clone_ATE(ATE p)
{
  switch(p->kind)
  {
  case is_ATE1:
    return make_ATE1
      ( clone_OPL(p->u.ate1_.opl_)
      , clone_Block(p->u.ate1_.block_)
      );

  default:
    fprintf(stderr, "Error: bad kind field when cloning ATE!\n");
    exit(1);
  }
}

FAZAI clone_FAZAI(FAZAI p)
{
  switch(p->kind)
  {
  case is_FAZAI1:
    return make_FAZAI1
      ( clone_Type(p->u.fazai1_.type_)
      , strdup(p->u.fazai1_.ident_)
      , clone_VALUE(p->u.fazai1_.value_)
      , clone_OPL(p->u.fazai1_.opl_)
      , p->u.fazai1_.integer_
      , clone_Block(p->u.fazai1_.block_)
      );

  default:
    fprintf(stderr, "Error: bad kind field when cloning FAZAI!\n");
    exit(1);
  }
}

VALUE clone_VALUE(VALUE p)
{
  switch(p->kind)
  {
  case is_VALUEIdent:
    return make_VALUEIdent (strdup(p->u.valueident_.ident_));

  case is_VALUEString:
    return make_VALUEString (strdup(p->u.valuestring_.string_));

  case is_VALUEInteger:
    return make_VALUEInteger (p->u.valueinteger_.integer_);

  case is_VALUEDouble:
    return make_VALUEDouble (p->u.valuedouble_.double_);

  default:
    fprintf(stderr, "Error: bad kind field when cloning VALUE!\n");
    exit(1);
  }
}

Type clone_Type(Type p)
{
  switch(p->kind)
  {
  case is_Type_interu:
    return make_Type_interu ();

  case is_Type_floaty:
    return make_Type_floaty ();

  case is_Type_stringo:
    return make_Type_stringo ();

  default:
    fprintf(stderr, "Error: bad kind field when cloning Type!\n");
    exit(1);
  }
}

VET clone_VET(VET p)
{
  switch(p->kind)
  {
  case is_VET1:
    return make_VET1
      ( clone_Type(p->u.vet1_.type_)
      , strdup(p->u.vet1_.ident_)
      , p->u.vet1_.integer_
      );

  case is_VET2:
    return make_VET2
      ( strdup(p->u.vet2_.ident_)
      , p->u.vet2_.integer_
      , clone_ConjInt(p->u.vet2_.conjint_)
      );

  case is_VET3:
    return make_VET3
      ( strdup(p->u.vet3_.ident_)
      , p->u.vet3_.integer_
      , clone_ConjReal(p->u.vet3_.conjreal_)
      );

  case is_VET4:
    return make_VET4
      ( strdup(p->u.vet4_.ident_)
      , p->u.vet4_.integer_
      , clone_ConjString(p->u.vet4_.conjstring_)
      );

  default:
    fprintf(stderr, "Error: bad kind field when cloning VET!\n");
    exit(1);
  }
}

STRUCT clone_STRUCT(STRUCT p)
{
  switch(p->kind)
  {
  case is_STRUCT1:
    return make_STRUCT1
      ( p->u.struct1_.integer_
      , clone_HeteroElements(p->u.struct1_.heteroelements_)
      );

  default:
    fprintf(stderr, "Error: bad kind field when cloning STRUCT!\n");
    exit(1);
  }
}

HeteroElements clone_HeteroElements(HeteroElements p)
{
  switch(p->kind)
  {
  case is_HeteroElementsHeteroElement:
    return make_HeteroElementsHeteroElement (clone_HeteroElement(p->u.heteroelementsheteroelement_.heteroelement_));

  case is_HeteroElements1:
    return make_HeteroElements1
      ( clone_HeteroElement(p->u.heteroelements1_.heteroelement_)
      , clone_HeteroElements(p->u.heteroelements1_.heteroelements_)
      );

  default:
    fprintf(stderr, "Error: bad kind field when cloning HeteroElements!\n");
    exit(1);
  }
}

HeteroElement clone_HeteroElement(HeteroElement p)
{
  switch(p->kind)
  {
  case is_HeteroElementString:
    return make_HeteroElementString (strdup(p->u.heteroelementstring_.string_));

  case is_HeteroElementDouble:
    return make_HeteroElementDouble (p->u.heteroelementdouble_.double_);

  case is_HeteroElementInteger:
    return make_HeteroElementInteger (p->u.heteroelementinteger_.integer_);

  default:
    fprintf(stderr, "Error: bad kind field when cloning HeteroElement!\n");
    exit(1);
  }
}

FUNC clone_FUNC(FUNC p)
{
  switch(p->kind)
  {
  case is_FUNC1:
    return make_FUNC1
      ( strdup(p->u.func1_.ident_)
      , clone_Block(p->u.func1_.block_)
      );

  default:
    fprintf(stderr, "Error: bad kind field when cloning FUNC!\n");
    exit(1);
  }
}

GOTO clone_GOTO(GOTO p)
{
  switch(p->kind)
  {
  case is_GOTO1:
    return make_GOTO1 (p->u.goto1_.integer_);

  default:
    fprintf(stderr, "Error: bad kind field when cloning GOTO!\n");
    exit(1);
  }
}

LABEL clone_LABEL(LABEL p)
{
  switch(p->kind)
  {
  case is_LABEL1:
    return make_LABEL1
      ( p->u.label1_.integer_
      , clone_Block(p->u.label1_.block_)
      );

  default:
    fprintf(stderr, "Error: bad kind field when cloning LABEL!\n");
    exit(1);
  }
}

ConjInt clone_ConjInt(ConjInt p)
{
  switch(p->kind)
  {
  case is_ConjIntInteger:
    return make_ConjIntInteger (p->u.conjintinteger_.integer_);

  case is_ConjInt1:
    return make_ConjInt1
      ( p->u.conjint1_.integer_
      , clone_ConjInt(p->u.conjint1_.conjint_)
      );

  default:
    fprintf(stderr, "Error: bad kind field when cloning ConjInt!\n");
    exit(1);
  }
}

ConjReal clone_ConjReal(ConjReal p)
{
  switch(p->kind)
  {
  case is_ConjRealDouble:
    return make_ConjRealDouble (p->u.conjrealdouble_.double_);

  case is_ConjReal1:
    return make_ConjReal1
      ( p->u.conjreal1_.double_
      , clone_ConjReal(p->u.conjreal1_.conjreal_)
      );

  default:
    fprintf(stderr, "Error: bad kind field when cloning ConjReal!\n");
    exit(1);
  }
}

ConjString clone_ConjString(ConjString p)
{
  switch(p->kind)
  {
  case is_ConjStringString:
    return make_ConjStringString (strdup(p->u.conjstringstring_.string_));

  case is_ConjString1:
    return make_ConjString1
      ( strdup(p->u.conjstring1_.string_)
      , clone_ConjString(p->u.conjstring1_.conjstring_)
      );

  default:
    fprintf(stderr, "Error: bad kind field when cloning ConjString!\n");
    exit(1);
  }
}

CONST clone_CONST(CONST p)
{
  switch(p->kind)
  {
  case is_LConst:
    return make_LConst
      ( clone_Type(p->u.lconst_.type_)
      , strdup(p->u.lconst_.ident_)
      , clone_VALUE(p->u.lconst_.value_)
      );

  default:
    fprintf(stderr, "Error: bad kind field when cloning CONST!\n");
    exit(1);
  }
}

POINT clone_POINT(POINT p)
{
  switch(p->kind)
  {
  case is_LPoint:
    return make_LPoint
      ( clone_Type(p->u.lpoint_.type_)
      , strdup(p->u.lpoint_.ident_1)
      , strdup(p->u.lpoint_.ident_2)
      );

  default:
    fprintf(stderr, "Error: bad kind field when cloning POINT!\n");
    exit(1);
  }
}

/********************   Recursive Destructors    **********************/

/* These free an entire abstract syntax tree
 * including all subtrees and strings.
 *
 * Will not work properly if there is sharing in the tree,
 * i.e., when some pointers are aliased.  In this case
 * it will attempt to free the same memory twice.
 */

void free_S(S p)
{
  switch(p->kind)
  {
  case is_Sst:
    free_Block(p->u.sst_.block_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing S!\n");
    exit(1);
  }
  free(p);
}

void free_Block(Block p)
{
  switch(p->kind)
  {
  case is_LBlock:
    free_CMDS(p->u.lblock_.cmds_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing Block!\n");
    exit(1);
  }
  free(p);
}

void free_CMDS(CMDS p)
{
  switch(p->kind)
  {
  case is_CMDSCMD:
    free_CMD(p->u.cmdscmd_.cmd_);
    break;

  case is_CMDS1:
    free_CMD(p->u.cmds1_.cmd_);
    free_CMDS(p->u.cmds1_.cmds_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing CMDS!\n");
    exit(1);
  }
  free(p);
}

void free_CMD(CMD p)
{
  switch(p->kind)
  {
  case is_CMDATB:
    free_ATB(p->u.cmdatb_.atb_);
    break;

  case is_CMDSE:
    free_SE(p->u.cmdse_.se_);
    break;

  case is_CMDATE:
    free_ATE(p->u.cmdate_.ate_);
    break;

  case is_CMDFAZAI:
    free_FAZAI(p->u.cmdfazai_.fazai_);
    break;

  case is_CMDCLAUDDIZ:
    free_CLAUDDIZ(p->u.cmdclauddiz_.clauddiz_);
    break;

  case is_CMDRECEBA:
    free_RECEBA(p->u.cmdreceba_.receba_);
    break;

  case is_CMDCONST:
    free_CONST(p->u.cmdconst_.const_);
    break;

  case is_CMDVET:
    free_VET(p->u.cmdvet_.vet_);
    break;

  case is_CMDFUNC:
    free_FUNC(p->u.cmdfunc_.func_);
    break;

  case is_CMDGOTO:
    free_GOTO(p->u.cmdgoto_.goto_);
    break;

  case is_CMDLABEL:
    free_LABEL(p->u.cmdlabel_.label_);
    break;

  case is_CMDSTRUCT:
    free_STRUCT(p->u.cmdstruct_.struct_);
    break;

  case is_CMDPOINT:
    free_POINT(p->u.cmdpoint_.point_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing CMD!\n");
    exit(1);
  }
  free(p);
}

void free_ATB(ATB p)
{
  switch(p->kind)
  {
  case is_ATB1:
    free_Type(p->u.atb1_.type_);
    free(p->u.atb1_.ident_);
    free_VALUE(p->u.atb1_.value_);
    break;

  case is_ATB2:
    free_Type(p->u.atb2_.type_);
    free(p->u.atb2_.ident_);
    free_EXP(p->u.atb2_.exp_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing ATB!\n");
    exit(1);
  }
  free(p);
}

void free_EXP(EXP p)
{
  switch(p->kind)
  {
  case is_EXP1:
    free_VALUE(p->u.exp1_.value_1);
    free_OPerA(p->u.exp1_.opera_);
    free_VALUE(p->u.exp1_.value_2);
    break;

  case is_EXP2:
    free_EXP(p->u.exp2_.exp_);
    free_OPerA(p->u.exp2_.opera_);
    free_VALUE(p->u.exp2_.value_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing EXP!\n");
    exit(1);
  }
  free(p);
}

void free_SE(SE p)
{
  switch(p->kind)
  {
  case is_SE1:
    free_OPL(p->u.se1_.opl_);
    free_Block(p->u.se1_.block_);
    break;

  case is_SE2:
    free_OPL(p->u.se2_.opl_);
    free_Block(p->u.se2_.block_1);
    free_Block(p->u.se2_.block_2);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing SE!\n");
    exit(1);
  }
  free(p);
}

void free_OPerL(OPerL p)
{
  switch(p->kind)
  {
  case is_OPerL1:
    break;

  case is_OPerL2:
    break;

  case is_OPerL3:
    break;

  case is_OPerL4:
    break;

  case is_OPerL5:
    break;

  case is_OPerL6:
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing OPerL!\n");
    exit(1);
  }
  free(p);
}

void free_OPerA(OPerA p)
{
  switch(p->kind)
  {
  case is_OPerA1:
    break;

  case is_OPerA2:
    break;

  case is_OPerA3:
    break;

  case is_OPerA4:
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing OPerA!\n");
    exit(1);
  }
  free(p);
}

void free_OPL(OPL p)
{
  switch(p->kind)
  {
  case is_OPL1:
    free_VALUE(p->u.opl1_.value_1);
    free_OPerL(p->u.opl1_.operl_);
    free_VALUE(p->u.opl1_.value_2);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing OPL!\n");
    exit(1);
  }
  free(p);
}

void free_CLAUDDIZ(CLAUDDIZ p)
{
  switch(p->kind)
  {
  case is_CLAUDDIZ1:
    free_VALUE(p->u.clauddiz1_.value_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing CLAUDDIZ!\n");
    exit(1);
  }
  free(p);
}

void free_RECEBA(RECEBA p)
{
  switch(p->kind)
  {
  case is_RECEBA1:
    free_Type(p->u.receba1_.type_);
    free(p->u.receba1_.ident_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing RECEBA!\n");
    exit(1);
  }
  free(p);
}

void free_ATE(ATE p)
{
  switch(p->kind)
  {
  case is_ATE1:
    free_OPL(p->u.ate1_.opl_);
    free_Block(p->u.ate1_.block_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing ATE!\n");
    exit(1);
  }
  free(p);
}

void free_FAZAI(FAZAI p)
{
  switch(p->kind)
  {
  case is_FAZAI1:
    free_Type(p->u.fazai1_.type_);
    free(p->u.fazai1_.ident_);
    free_VALUE(p->u.fazai1_.value_);
    free_OPL(p->u.fazai1_.opl_);
    free_Block(p->u.fazai1_.block_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing FAZAI!\n");
    exit(1);
  }
  free(p);
}

void free_VALUE(VALUE p)
{
  switch(p->kind)
  {
  case is_VALUEIdent:
    free(p->u.valueident_.ident_);
    break;

  case is_VALUEString:
    free(p->u.valuestring_.string_);
    break;

  case is_VALUEInteger:
    break;

  case is_VALUEDouble:
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing VALUE!\n");
    exit(1);
  }
  free(p);
}

void free_Type(Type p)
{
  switch(p->kind)
  {
  case is_Type_interu:
    break;

  case is_Type_floaty:
    break;

  case is_Type_stringo:
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing Type!\n");
    exit(1);
  }
  free(p);
}

void free_VET(VET p)
{
  switch(p->kind)
  {
  case is_VET1:
    free_Type(p->u.vet1_.type_);
    free(p->u.vet1_.ident_);
    break;

  case is_VET2:
    free(p->u.vet2_.ident_);
    free_ConjInt(p->u.vet2_.conjint_);
    break;

  case is_VET3:
    free(p->u.vet3_.ident_);
    free_ConjReal(p->u.vet3_.conjreal_);
    break;

  case is_VET4:
    free(p->u.vet4_.ident_);
    free_ConjString(p->u.vet4_.conjstring_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing VET!\n");
    exit(1);
  }
  free(p);
}

void free_STRUCT(STRUCT p)
{
  switch(p->kind)
  {
  case is_STRUCT1:
    free_HeteroElements(p->u.struct1_.heteroelements_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing STRUCT!\n");
    exit(1);
  }
  free(p);
}

void free_HeteroElements(HeteroElements p)
{
  switch(p->kind)
  {
  case is_HeteroElementsHeteroElement:
    free_HeteroElement(p->u.heteroelementsheteroelement_.heteroelement_);
    break;

  case is_HeteroElements1:
    free_HeteroElement(p->u.heteroelements1_.heteroelement_);
    free_HeteroElements(p->u.heteroelements1_.heteroelements_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing HeteroElements!\n");
    exit(1);
  }
  free(p);
}

void free_HeteroElement(HeteroElement p)
{
  switch(p->kind)
  {
  case is_HeteroElementString:
    free(p->u.heteroelementstring_.string_);
    break;

  case is_HeteroElementDouble:
    break;

  case is_HeteroElementInteger:
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing HeteroElement!\n");
    exit(1);
  }
  free(p);
}

void free_FUNC(FUNC p)
{
  switch(p->kind)
  {
  case is_FUNC1:
    free(p->u.func1_.ident_);
    free_Block(p->u.func1_.block_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing FUNC!\n");
    exit(1);
  }
  free(p);
}

void free_GOTO(GOTO p)
{
  switch(p->kind)
  {
  case is_GOTO1:
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing GOTO!\n");
    exit(1);
  }
  free(p);
}

void free_LABEL(LABEL p)
{
  switch(p->kind)
  {
  case is_LABEL1:
    free_Block(p->u.label1_.block_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing LABEL!\n");
    exit(1);
  }
  free(p);
}

void free_ConjInt(ConjInt p)
{
  switch(p->kind)
  {
  case is_ConjIntInteger:
    break;

  case is_ConjInt1:
    free_ConjInt(p->u.conjint1_.conjint_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing ConjInt!\n");
    exit(1);
  }
  free(p);
}

void free_ConjReal(ConjReal p)
{
  switch(p->kind)
  {
  case is_ConjRealDouble:
    break;

  case is_ConjReal1:
    free_ConjReal(p->u.conjreal1_.conjreal_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing ConjReal!\n");
    exit(1);
  }
  free(p);
}

void free_ConjString(ConjString p)
{
  switch(p->kind)
  {
  case is_ConjStringString:
    free(p->u.conjstringstring_.string_);
    break;

  case is_ConjString1:
    free(p->u.conjstring1_.string_);
    free_ConjString(p->u.conjstring1_.conjstring_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing ConjString!\n");
    exit(1);
  }
  free(p);
}

void free_CONST(CONST p)
{
  switch(p->kind)
  {
  case is_LConst:
    free_Type(p->u.lconst_.type_);
    free(p->u.lconst_.ident_);
    free_VALUE(p->u.lconst_.value_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing CONST!\n");
    exit(1);
  }
  free(p);
}

void free_POINT(POINT p)
{
  switch(p->kind)
  {
  case is_LPoint:
    free_Type(p->u.lpoint_.type_);
    free(p->u.lpoint_.ident_1);
    free(p->u.lpoint_.ident_2);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing POINT!\n");
    exit(1);
  }
  free(p);
}

